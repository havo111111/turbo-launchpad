import{u as e,g as t,a as r,b as o,c as i,d as n,C as s,e as l,s as d,P as h,f as w,h as p,i as m,G as y,W as k,j as f,k as C,l as W,m as v,n as P,o as _,p as x,q as j,r as q,t as G,v as $,w as Y,x as Z,y as ee}from"./privy-provider-CeZefZDF.mjs";export{B as Captcha,D as ConnectorManager,F as EthereumWalletConnector,X as LoginModal,N as PrivyClient,z as PrivyProvider,V as VERSION,E as WalletConnector,L as errorIndicatesMaxMfaRetries,M as errorIndicatesMfaTimeout,K as errorIndicatesMfaVerificationFailed,A as getAccessToken,S as useCreateWallet,O as useIdentityToken,U as useImportWallet,Q as useLogout,I as useMfa,J as useMfaEnrollment,H as usePrivy,R as useRegisterMfaListener,T as useSolanaWallets}from"./privy-provider-CeZefZDF.mjs";import{useCallback as te,useMemo as re,useEffect as oe,useContext as ie,useState as ae,useRef as ne}from"react";import{u as se,P as le,a as ce,I as ue}from"./internal-context-BOEPXMqX.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-BzaD7wH1.mjs";import{F as de}from"./frame-DcLJJ5Fa.mjs";import{zeroAddress as he,getAddress as we,createWalletClient as pe,http as ge,parseSignature as me}from"viem";import{hashAuthorization as ye}from"viem/utils";import{getWallet as Ae,updateWallet as ke}from"@privy-io/js-sdk-core";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import"react/jsx-runtime";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ShieldCheckIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"zustand";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/CheckIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/ArrowTopRightOnSquareIcon";import"@heroicons/react/24/solid/DocumentCheckIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"qrcode";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/LockClosedIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"ofetch";import"@heroicons/react/24/outline";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/outline/CloudArrowUpIcon";import"@heroicons/react/24/outline/NoSymbolIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/outline/TrashIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const fe=()=>{let{user:o}=e(),{walletProxy:i}=se();return{recover:te((async e=>{if(!i)throw Error("Wallet proxy is not ready");let a=await t();if(!o||!a)throw new le("User must be logged in before attempting to modify the recovery method.");let{entropyId:n,entropyIdVerifier:s}=r(o);try{await i.recover({entropyId:n,entropyIdVerifier:s,accessToken:a,...e})}catch{throw new le("Unable to recover wallets")}}),[i,o])}},Ce=()=>{let{client:e,setAuthenticated:t,setUser:r}=se();return re((()=>({init:async()=>{if(!e)throw new le("Must initialize Privy client first.");let t=new de;return e.startAuthFlow(t),await t.init()},login:async({fid:o,message:i,signature:a})=>{if(!e)throw new le("Must initialize Privy client first.");if(!(e.authFlow instanceof de))throw new le("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:i,signature:a,fid:o});let{user:n}=await e.authenticate();if(!n)throw new le("Failed to login with Farcaster V2");return r(n),t(!0),{user:n}}})),[e,r,t])},Ie=t=>{o("login",t);let r=i(),a=n(),{ready:c,user:u}=e(),{initLoginWithHeadlessOAuth:h,loginWithHeadlessOAuth:w,oAuthState:p,setOAuthState:g,isHeadlessOAuthLoading:m}=se(),y=te((async e=>{try{if(r.enabled&&"success"!==r.status)throw new s(r.error,null,ce.CAPTCHA_FAILURE);return await h(e.provider,r.token,e.disableSignup)}catch(e){throw g({status:"error",error:e}),e}}),[h,r]),A=te((async()=>{let e=l();try{if(u)return console.warn("Cannot login with OAuth when already logged in"),u;if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(e.popupFlow)return}catch(e){throw g({status:"error",error:e}),e}try{return await w(e)}catch(e){throw g({status:"error",error:e}),e}finally{d()}}),[w]);return oe((()=>{let e=l();c&&a&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&A().catch((()=>{}))}),[c,a]),{initOAuth:y,loading:m,state:p}},Ee=e=>{let t=i(),{emailOtpState:r,setEmailOtpState:o,initLoginWithEmail:a,loginWithCode:n}=se();return{sendCode:te((async({email:r,disableSignup:i})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({email:r,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:te((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:l}=await n(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},We=e=>{let t=i(),{initSignupWithPasskey:r,signupWithPasskey:o,passkeyAuthState:a,setPasskeyAuthState:n}=se();return{signupWithPasskey:te((async()=>{try{let i;if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),i=await t.waitForResult()),await r({captchaToken:i,withPrivyUi:!1});let{user:a,isNewUser:n,wasAlreadyAuthenticated:l,loginAccount:c}=await o();e?.onComplete?.({user:a,isNewUser:n,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(t){throw n({status:"error",error:t}),e?.onError?.(t.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),t}}),[o,t.status]),state:a}},Te=e=>{let t=i(),{initLoginWithPasskey:r,loginWithPasskey:o,passkeyAuthState:a,setPasskeyAuthState:n}=se();return{loginWithPasskey:te((async i=>{try{let a;if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult()),await r({captchaToken:a,withPrivyUi:!1});let{user:n,isNewUser:l,wasAlreadyAuthenticated:c,loginAccount:u}=await o(i);e?.onComplete?.({user:n,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:u})}catch(i){throw n({status:"error",error:i}),e?.onError?.(i.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),i}}),[o,t.status]),state:a}},Ue=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:o,setPasskeyAuthState:i}=se();return{linkWithPasskey:te((async()=>{try{await t();let o=await r();if(!o)throw Error("Error, user not found");let i=o.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:o,linkMethod:"passkey",linkedAccount:i})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||ce.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:o}},Se=e=>{let t=i(),{smsOtpState:r,setSmsOtpState:o,initLoginWithSms:a,loginWithCode:n}=se();return{sendCode:te((async({phoneNumber:r,disableSignup:i})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({phoneNumber:r,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:te((async({code:r})=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:l}=await n(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},ve=t=>{let{connectOrCreateWallet:r}=e();return o("connectOrCreateWallet",t),{connectOrCreateWallet:r}},Re=e=>{let t=i(),{siweState:r,setSiweState:o,linkWithSiwe:a,generateSiweMessage:n}=se();return{generateSiweMessage:te((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await n({address:t,chainId:r}).then((e=>e))}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||ce.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[n]),linkWithSiwe:te((async({signature:r,message:i,chainId:n,walletClientType:l,connectorType:c})=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);let{user:o,linkedAccount:u}=await a({message:i,signature:r,chainId:n,walletClientType:l,connectorType:c});u&&e?.onSuccess?.({user:o,linkMethod:"siwe",linkedAccount:u})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[a,t.status]),state:r}},Pe=e=>{let t=i(),{siweState:r,setSiweState:o,client:a,generateSiweMessage:n,loginWithSiwe:l}=se();return{generateSiweNonce:te((async r=>{try{let e;if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),o({status:"generating-message"});let i=await a.generateSiweNonce({address:r?.address,captchaToken:e});return o({status:"awaiting-signature"}),i}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),r}}),[a,t]),generateSiweMessage:te((async({address:t,chainId:r})=>{try{return await n({address:t,chainId:r})}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),t}}),[n]),loginWithSiwe:te((async({message:r,signature:i,disableSignup:a})=>{try{let o;if(t.enabled&&"error"===t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),o=await t.waitForResult());let n=await l({message:r,signature:i,captchaToken:o,disableSignup:a});return e?.onComplete?.({user:n,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),n}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),r}}),[l,t.status]),state:r}};function be(){let{signTransaction:e}=ie(h);return{signTransaction:e}}function Ne(e){let{linkEmail:t,linkPhone:r,linkWallet:i,linkGoogle:a,linkApple:n,linkTwitter:s,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkSpotify:w,linkInstagram:p,linkTelegram:g,linkFarcaster:m,linkPasskey:y}=ie(h);return o("linkAccount",e),{linkEmail:t,linkPhone:r,linkWallet:i,linkGoogle:a,linkApple:n,linkTwitter:s,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkSpotify:w,linkInstagram:p,linkFarcaster:m,linkTelegram:g,linkPasskey:y}}function Oe(e){let{updateEmail:t,updatePhone:r}=ie(h);return o("update",e),{updateEmail:t,updatePhone:r}}const _e=()=>{let{connectCoinbaseSmartWallet:e}=se();return{connectCoinbaseSmartWallet:e}},Me=()=>{let{startCrossAppAuthFlow:t,unlinkCrossAppAccount:r,signMessageWithCrossAppWallet:o,signTypedDataWithCrossAppWallet:i,sendTransactionWithCrossAppWallet:a}=e();return{loginWithCrossAppAccount:({appId:e})=>t({appId:e,action:"login"}),linkCrossAppAccount:({appId:e})=>t({appId:e,action:"link"}),unlinkCrossAppAccount:r,signMessage:o,signTypedData:i,sendTransaction:a}};function Fe(e){let{sendTransaction:t}=ie(h);return o("sendTransaction",e),{sendTransaction:t}}function Le(e){let{setWalletPassword:t}=ie(h);return o("setWalletPassword",e),{setWalletPassword:t}}function He(){let t=w(),{getAccessToken:r}=e(),o=p(),{client:i,setUser:a,setAuthenticated:n,setIsNewUser:s,initializeWalletProxy:l}=se(),{create:c}=m();return{createGuestAccount:async()=>{if(!t.id||!i)throw Error("SDK not yet ready");i.startAuthFlow(new y(t.id));try{let e=await i.authenticate(),u=e.user,d=e.isNewUser??!1;if(!u)throw new le("Unable to authenticate guest account");let h=await r(),w=await l(k);if(h&&w)try{let e=f(u,t.embeddedWallets.ethereum.createOnLogin),r=C(u,t.embeddedWallets.solana.createOnLogin);e&&r?(u=(await c({chainType:"ethereum",latestUser:u})).user,u=(await c({chainType:"solana",latestUser:u})).user):r?u=(await c({chainType:"solana",latestUser:u})).user:e?u=(await c({chainType:"ethereum",latestUser:u})).user:a(u)}catch(e){a(u),console.warn("Unable to create embedded wallet for guest account")}return s(d),n(!0),o("login","onComplete",{user:u,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),u}catch(e){throw o("login","onError",e.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),e}}}}function De(e){let{setWalletRecovery:t}=ie(h);return o("setWalletRecovery",e),{setWalletRecovery:t}}function xe(e){let{signMessage:t}=ie(h);return o("signMessage",e),{signMessage:t}}const Ke=()=>{let{ready:t,wallets:r}=W(),{user:o}=e(),{rpcConfig:i,chains:a,appId:n}=se();return{signAuthorization:te((async(e,s)=>{let l;if(!o)throw Error("User must be authenticated before signing with a Privy wallet");if(!t)throw Error("Wallets are not ready");let c=s?.address??v(o)?.address??he,u=r.find((e=>we(e.address)===we(c)));if(!u)throw Error("Signing wallet not found.");let d=e.chainId??Number(u.chainId.split(":")[1]);if(0===d)l={chainId:0,address:e.contractAddress,nonce:e.nonce??0};else{let t=a.find((e=>e.id===d));if(!t)throw Error("Error, chain not configured in PrivyProvider config");let r=pe({account:c,chain:t,transport:ge(P(t,i,n))});l=await r.prepareAuthorization({...e})}let h=await u.getEthereumProvider(),w=await h.request({method:"secp256k1_sign",params:[ye(l)]});return{...l,...me(w)}}),[t,r,o,a])}};function ze(e){let{signTypedData:t}=ie(h);return o("signTypedData",e),{signTypedData:t}}const je=()=>{let{isModalOpen:e}=ie(h);return{isOpen:e}};function qe(e){let{getAccessToken:t}=ie(h);return o("accessToken",e),{getAccessToken:t}}function Ve(t){let{authenticated:r,user:i}=e(),{initLoginWithOAuth:a}=se(),n=p();return o("oAuthAuthorization",t),{reauthorize:e=>Ge(r,i,a,n,e.provider)}}let Ge=async(e,t,r,o,i)=>{if(!e)throw o("linkAccount","onError",ce.MUST_BE_AUTHENTICATED,{linkMethod:i}),new le("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(i))))throw new le(`OAuth account of type ${i} not linked to the account.`);await r(i)};function Be(e){let{client:t}=se(),[r,o]=ae({status:"initial"});return{linkWithCustomJwt:te((async r=>{try{o({status:"initial"}),t.startAuthFlow(new _(r)),o({status:"loading"});let{user:i}=await t.link();if(!i)throw Error("Error, user not found");let a=i.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return o({status:"done"}),e?.onSuccess?.({user:i,linkMethod:"custom",linkedAccount:a}),{user:i}}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||ce.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[t.startAuthFlow,t.link]),state:r}}const Qe=e=>{let t=x();return o("customAuth",e),{status:t}};function Xe({isAuthenticated:e,isLoading:t,...r}){let o=ne();oe((()=>{t||o.current?.()}),[e,t]);let i=te((e=>(o.current=e,()=>{o.current=void 0})),[]);return j({...r,subscribe:i})}function Je(){let{getFarcasterSignerPublicKey:t,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:o}=e();return{getFarcasterSignerPublicKey:t,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:o}}const $e=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=se();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},Ye=()=>{let{addSessionSignersInternal:t,removeSessionSignersInternal:r}=(()=>{let{getAccessToken:t,user:r}=e(),o=se(),{signWithUserSigner:i}=q(),a=async({wallet:e,additional_signers:a})=>{let n=await t();if(!r||!n)throw new le("User must be authenticated and have an embedded wallet to delegate actions.");if(!e.id)throw new le("Wallet to add signers to must have ID on server");if(!o.walletProxy)throw new le("Wallet proxy not initialized.");await ke(o.privy,{wallet_id:e.id},i,{additional_signers:a})};return{addSessionSignersInternal:async({address:e,signers:i})=>{let n=await t();if(!r||!n)throw new le("User must be authenticated and have an embedded wallet to add a session signer.");let s=o.walletProxy??await o.initializeWalletProxy(15e3);if(!s)throw new le("Wallet proxy not initialized.");let l=G(r,e);if(!l)throw new le("Address to add signers too is not associated with current user.");if($(l)){if(0===i.length)throw new le("Must specify at least one signer to add.");let e=[...(await Ae(o.privy,{wallet_id:l.id})).additional_signers,...Y(i)];await a({wallet:l,additional_signers:e})}else{if(l.delegated)return{user:r};if(i.length>0)throw new le("This embedded wallet does not support specifying signers. If signing is enabled in the dashboard, signer will default to that key. Otherwise, no signatures will be required for the wallet.");let t=Z({address:e,user:r}),a=ee({address:e,user:r});await o.recoverEmbeddedWallet({address:e}),await s.createDelegatedAction({accessToken:n,rootWallet:a,delegatedWallets:[t]})}let c=await o.refreshSessionAndUser();if(!c)throw Error("Could not refresh user");return{user:c}},removeSessionSignersInternal:async({address:e})=>{let i=await t();if(!r||!i)throw new le("User must be authenticated and have an embedded wallet to delegate actions.");if(!(o.walletProxy??await o.initializeWalletProxy(15e3)))throw new le("Wallet proxy not initialized.");let n=G(r,e);if(!n)throw new le("Address to remove signers from is not associated with current user.");$(n)?await a({wallet:n,additional_signers:[]}):await o.client.revokeDelegatedWallet();let s=await o.refreshSessionAndUser();if(!s)throw Error("Could not refresh user");return{user:s}}}})();return{addSessionSigners:async({address:e,signers:r})=>t({address:e,signers:r}),removeSessionSigners:async({address:e})=>r({address:e})}},Ze=()=>{let{setUser:e,client:t}=ie(ue),{user:r}=ie(h);return{user:r,refreshUser:te((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},et=e=>{let t=i(),{initLoginWithTelegram:r,loginWithTelegram:o,telegramAuthState:a,setTelegramAuthState:n}=se();return{login:te((async i=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,ce.CAPTCHA_FAILURE);await r(t.token,i?.disableSignup);let{user:a,isNewUser:n,loginAccount:l,wasAlreadyAuthenticated:c}=await o({intent:"login"});e?.onComplete?.({user:a,isNewUser:n,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:l})}catch(i){throw n({status:"error",error:i}),e?.onError?.(i.privyErrorCode||ce.UNKNOWN_AUTH_ERROR),i}}),[r,o,t]),state:a}},tt=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=se();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}};export{_e as useConnectCoinbaseSmartWallet,ve as useConnectOrCreateWallet,Me as useCrossAppAccounts,Qe as useCustomAuth,$e as useDelegatedActions,Je as useFarcasterSigner,He as useGuestAccounts,tt as useHeadlessDelegatedActions,Ne as useLinkAccount,Be as useLinkJwtAccount,Ue as useLinkWithPasskey,Re as useLinkWithSiwe,Ee as useLoginWithEmail,Ce as useLoginWithFarcasterV2,Ie as useLoginWithOAuth,Te as useLoginWithPasskey,Pe as useLoginWithSiwe,Se as useLoginWithSms,et as useLoginWithTelegram,je as useModalStatus,Ve as useOAuthTokens,fe as useRecoverEmbeddedWallet,Fe as useSendTransaction,Ye as useSessionSigners,Le as useSetWalletPassword,De as useSetWalletRecovery,Ke as useSignAuthorization,xe as useSignMessage,be as useSignTransaction,ze as useSignTypedData,We as useSignupWithPasskey,Xe as useSubscribeToJwtAuthWithFlag,j as useSyncJwtBasedAuthState,qe as useToken,Oe as useUpdateAccount,Ze as useUser,W as useWallets};
